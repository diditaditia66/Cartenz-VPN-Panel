// server.cjs â€” Cartenz Panel (SSE streaming + billing + trial limit + clean output + manage ssh)

const fs = require("fs");
const path = require("path");
const express = require("express");
const session = require("express-session");
const bcrypt = require("bcryptjs");
const { spawn, exec } = require("child_process");
const { EventEmitter } = require("events");

// ===== Konfigurasi =====
const PORT = process.env.PORT ? Number(process.env.PORT) : 8080;
const SESSION_SECRET = process.env.SESSION_SECRET || "dev_secret_ubah_dengan_ENV";
const PRICE_ADD = 5000; // harga per Add account untuk non-admin

const APP_DIR   = __dirname;
const DATA_FILE = path.join(APP_DIR, "users.json");
const PUBLIC_DIR= path.join(APP_DIR, "public");

// ===== users.json helper =====
function ensureUsers() {
  if (!fs.existsSync(DATA_FILE)) {
    const passhash = bcrypt.hashSync("ganti_password", 12);
    fs.writeFileSync(
      DATA_FILE,
      JSON.stringify([{ username: "admin", passhash, role: "admin", balance: 0, lastTrialDate: null }], null, 2)
    );
    console.log("[init] users.json dibuat. User: admin / ganti_password (segera ganti!)");
  }
}
function readUsers() {
  try { return JSON.parse(fs.readFileSync(DATA_FILE, "utf8")); }
  catch { return []; }
}
function writeUsers(arr) { fs.writeFileSync(DATA_FILE, JSON.stringify(arr, null, 2)); }
function getUser(username) { return readUsers().find(u => u.username === username); }
function saveUser(u) {
  const arr = readUsers();
  const i = arr.findIndex(x => x.username === u.username);
  if (i >= 0) arr[i] = u; else arr.push(u);
  writeUsers(arr);
}

// ===== App =====
const app = express();
app.set("trust proxy", 1);
// header security (HSTS, CSP, dll)
app.use((req, res, next) => {
  // Paksa HTTPS ke depannya (browser akan mengingat 1 tahun)
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
  // Upgrade semua http:// di halaman menjadi https://
  res.setHeader("Content-Security-Policy", "upgrade-insecure-requests");
  // Hardening header lain
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("Referrer-Policy", "strict-origin-when-cross-origin");
  next();
});
app.use(express.json({ limit: "1mb" }));
app.use(express.urlencoded({ extended: true }));
app.use(session({
  name: "cartenz.sid",
  secret: SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    sameSite: "lax",
    maxAge: 7 * 24 * 60 * 60 * 1000,
    secure: true,         // <-- wajib true agar tidak ditandai â€œNot secureâ€ di HTTPS
  },
}));
if (fs.existsSync(PUBLIC_DIR)) app.use(express.static(PUBLIC_DIR, { maxAge: 0 }));

// ===== Auth =====
function authRequired(req, res, next) {
  if (req.session && req.session.user) return next();
  return res.status(401).json({ error: "unauthorized" });
}
function adminRequired(req, res, next) {
  if (req.session?.user?.role === "admin") return next();
  return res.status(403).json({ error: "forbidden" });
}

app.post("/api/login", (req, res) => {
  const { username = "", password = "" } = req.body || {};
  const u = readUsers().find((x) => x.username === username);
  if (!u) return res.status(400).json({ error: "Invalid credentials" });
  if (!bcrypt.compareSync(password, u.passhash))
    return res.status(400).json({ error: "Invalid credentials" });
  req.session.user = { username: u.username, role: u.role || "admin" };
  res.json({ ok: true, user: { username: u.username, role: u.role || "admin", balance: u.balance || 0 } });
});
app.post("/api/logout", (req, res) => req.session.destroy(() => res.json({ ok: true })));
app.get("/api/me", (req, res) => {
  if (!req.session?.user) return res.json({ user: null });
  const u = getUser(req.session.user.username);
  res.json({ user: u ? { username: u.username, role: u.role || "admin", balance: u.balance || 0 } : null });
});
app.post("/api/change-password", authRequired, (req, res) => {
  const { oldPassword = "", newPassword = "" } = req.body || {};
  if (!newPassword || newPassword.length < 6)
    return res.status(400).json({ error: "Password baru minimal 6 karakter" });
  const users = readUsers();
  const i = users.findIndex((x) => x.username === req.session.user.username);
  if (i < 0) return res.status(400).json({ error: "User tidak ditemukan" });
  if (!bcrypt.compareSync(oldPassword, users[i].passhash))
    return res.status(400).json({ error: "Password lama salah" });
  users[i].passhash = bcrypt.hashSync(newPassword, 12);
  writeUsers(users);
  res.json({ ok: true });
});

// ===== Shell helpers =====
// ESC seq + CR stripper
const ANSI_REGEX = /\u001b\[[0-9;?]*[ -/]*[@-~]|\u001b[@-Z\\-_]|\r/g;
const stripAnsi = (s = "") => s.replace(ANSI_REGEX, "");

// Baris yang pasti dibuang (MOTD, info sistem, banner scan, dll)
const DROP_PATTERNS = [
  /^OS:/i, /^Host:/i, /^Kernel:/i, /^Uptime:/i, /^Packages:/i, /^Shell:/i, /^Resolution:/i,
  /^Terminal:/i, /^CPU:/i, /^GPU:/i, /^Memory:/i, /^Type 'menu' to display/i, /^Ping Host/i,
  /^Create Akun/i, /^Setting Password/i,            // sisa-sisa skrip internal
  /^[ :.+\-=_]{6,}:[ :.+\-=_]{0,}$/                 // ASCII-art bertitik/plus/kolon
];

// Judul blok yang diizinkan (semua variasi di contoh)
const KEEP_TITLES = new RegExp(
  '^\\s*(?:' + [
    'CartenzVPN\\s+â€”\\s+ADD\\s+(SSH|VMESS|VLESS|TROJAN|SHADOWSOCKS)',
    'CartenzVPN\\s+â€”\\s+TRIAL\\s+(SSH|VMESS|VLESS|TROJAN|SHADOWSOCKS)',
    'SSH\\s+Account','TRIAL\\s+SSH','Vmess\\s+Account','Trial\\s+Mmess',
    'Vless\\s+Account','Trial\\s+Vless','TROJAN\\s+ACCOUNT','TRIAL\\s+TROJAN',
    'Payload\\s+WSS','Payload\\s+WS','Shadowsocks\\s+Account',
    'VMESS','VLESS','TROJAN','SHADOWSOCKS'
  ].join('|') + ')\\s*$',
  'i'
);

// Garis pemisah yang diizinkan
const KEEP_RULE = /^[-=â”]{10,}\s*$/;

// Label berformat "NamaLabel : nilai" (punya titik dua di output)
const KEEP_LABELS_COLON = new RegExp(
  '^\\s*(?:' + [
    // SSH / umum
    'Username','Password','Expired\\s*On','Expired',
    'IP','Host','Host\\/IP',
    'OpenSSH','Dropbear','SSH\\s+WS','SSH\\s+SSL\\s+WS','SSL\\/TLS','UDPGW',
    // XRAY family
    'Remarks','Domain','Wildcard',
    'Port\\s+TLS','Port\\s+none\\s+TLS','Port\\s+gRPC',
    'id','ID','alterId','Security','Encryption','Network','Path','ServiceName','Ciphers','Key',
    // Link output
    'Link\\s+TLS','Link\\s+none\\s+TLS','Link\\s+gRPC'
  ].join('|') + ')\\s*:',
  'i'
);

// â¬‡ï¸ Baris payload tanpa titik dua: GET/POST â€¦ HTTP/1.x dan yang mengandung [crlf]
const KEEP_HTTP_LINE = /^\s*(?:GET|POST)\s+\S+\s+HTTP\/\d\.\d/i;
const KEEP_HAS_CRLF  = /\[crlf\]/i;

function shouldDrop(line) {
  return DROP_PATTERNS.some(re => re.test(line));
}

function shouldKeep(line) {
  if (shouldDrop(line)) return false;
  if (KEEP_RULE.test(line))         return true; // garis â”â”â” / ==== / ----
  if (KEEP_TITLES.test(line))       return true; // judul blok
  if (KEEP_LABELS_COLON.test(line)) return true; // label "Xxx: yyy"
  if (KEEP_HTTP_LINE.test(line))    return true; // GET/POST â€¦ HTTP/1.x
  if (KEEP_HAS_CRLF.test(line))     return true; // baris berisi [crlf]
  // Tidak ada fallbackâ€”baris lain dibuang
  return false;
}

function sh(cmd, { timeout = 120000 } = {}) {
  return new Promise((resolve, reject) => {
    exec(
      cmd,
      {
        shell: "/bin/bash",
        timeout,
        maxBuffer: 5 * 1024 * 1024,
        env: {
          ...process.env,
          TERM: "dumb",
          LC_ALL: "C",
          COLUMNS: "120",
          LINES: "40",
          NONINTERACTIVE: "1",
        },
      },
      (err, stdout, stderr) => {
        const raw = `${stdout || ""}${stderr || ""}`;
        const cleaned = stripAnsi(raw).trim();
        if (err) return reject(new Error(cleaned || err.message));
        resolve(cleaned || "(no output)");
      }
    );
  });
}

// streaming: kirim tiap baris sudah difilter
function shStream(cmd, onLine) {
  return new Promise((resolve, reject) => {
    const child = spawn("/bin/bash", ["-lc", cmd], {
      env: { ...process.env, TERM: "dumb", LC_ALL: "C", COLUMNS: "120", LINES: "40", NONINTERACTIVE: "1" }
    });
    let bufOut = ""; let bufErr = ""; let lastKept = "";
    const pushLines = (buf) => {
      const s = stripAnsi(buf);
      s.split(/\n/).forEach(line => {
        const l = line.trimEnd();
        if (l === "") return;
        if (shouldKeep(l)) {
          if (l !== lastKept) { onLine(l); lastKept = l; }
        }
      });
    };
    child.stdout.on("data", (c)=> { bufOut += c.toString(); const parts = bufOut.split(/\n/); bufOut = parts.pop(); parts.forEach(pushLines); });
    child.stderr.on("data", (c)=> { bufErr += c.toString(); const parts = bufErr.split(/\n/); bufErr = parts.pop(); parts.forEach(pushLines); });
    child.on("error", (e)=> reject(e));
    child.on("close", () => { if (bufOut) pushLines(bufOut); if (bufErr) pushLines(bufErr); resolve(); });
  });
}
function randPass(len = 10) {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789";
  let s = "";
  for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)];
  return s;
}
function fileExists(p) { try { fs.accessSync(p, fs.constants.X_OK); return true; } catch { return false; } }

// ===== Peta perintah =====
const TRIAL_MAP = {
  ssh: "/usr/bin/trial",
  vmess: "/usr/bin/trialvmess",
  vless: "/usr/bin/trialvless",
  trojan: "/usr/bin/trialtrojan",
  ss: "/usr/bin/trialssws",
};
const ADD_MAP = {
  vmess: { feed: (r, d) => `printf '%s\n%s\n' '${r}' '${d}' | /usr/bin/add-ws` },
  vless: { feed: (r, d) => `printf '%s\n%s\n' '${r}' '${d}' | /usr/bin/add-vless` },
  trojan:{ feed: (r, d) => `printf '%s\n%s\n' '${r}' '${d}' | /usr/bin/add-tr` },
  ss:    { feed: (r, d) => `printf '%s\n%s\n' '${r}' '${d}' | /usr/bin/add-ssws` },
};

// ===== Helper: tanggal lokal (Asia/Jakarta) =====
function todayJakarta() {
  return new Date().toLocaleDateString("en-CA", { timeZone: "Asia/Jakarta" }); // YYYY-MM-DD
}

// ====== Trial lock (anti spam / race) ======
const trialBusy = new Set(); // berisi username yang sedang proses trial

// ===== Endpoint lama (JSON) â€” Admin bebas limit; user 1x/hari =====
app.post("/api/trial/:kind", authRequired, async (req, res) => {
  try {
    const uname = req.session.user.username;
    const kind = String(req.params.kind || "").toLowerCase();
    const script = TRIAL_MAP[kind];
    if (!script) return res.status(400).json({ error: "Unsupported kind" });

    const uFresh0 = getUser(uname) || { username: uname, role: "user", balance: 0, lastTrialDate: null };
    const isAdmin = (uFresh0.role || "user") === "admin";

    // lock per user (tetap ada agar tidak double-exec paralel), tapi admin tetap diproses cepat
    if (trialBusy.has(uname)) {
      return res.status(429).json({ error: "Trial sedang diproses" });
    }
    trialBusy.add(uname);
    try {
      if (!isAdmin) {
        // user biasa: cek jatah harian
        const today = todayJakarta();
        const uFresh = getUser(uname) || uFresh0;
        if (uFresh.lastTrialDate === today) {
          return res.status(429).json({ error: "Trial hari ini sudah digunakan" });
        }
        // catat pemakaian
        uFresh.lastTrialDate = today;
        saveUser(uFresh);
      }
      const out = await sh(script);
      return res.json({ output: out });
    } finally {
      trialBusy.delete(uname);
    }
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// ===== Add lama (JSON) â€” jaga saldo agar tak bypass SSE =====
async function handleAddSSH_json(req, res) {
  try {
    const username = (req.body.username || req.body.remarks || "").trim();
    const passwordRaw = (req.body.password || "").toString();
    const days = parseInt(req.body.days, 10) || 30;
    const password = passwordRaw || randPass();
    if (!/^[a-zA-Z0-9_][a-zA-Z0-9_\-]{1,31}$/.test(username))
      return res.status(400).json({ error: "username invalid" });
    if (days < 1 || days > 3650) return res.status(400).json({ error: "days out of range" });

    const sessUser = getUser(req.session.user.username);
    if (sessUser && (sessUser.role || "user") !== "admin") {
      if (Number(sessUser.balance || 0) < PRICE_ADD)
        return res.status(402).json({ error: "Saldo tidak cukup" });
    }

    const safePass = password.replace(/'/g, "'\\''");
    const cmd = `printf '%s\n%s\n%s\n' '${username}' '${safePass}' '${days}' | /usr/bin/usernew`;
    const out = await sh(cmd, { timeout: 180000 });

    if (sessUser && (sessUser.role || "user") !== "admin") {
      sessUser.balance = Math.max(0, Number(sessUser.balance || 0) - PRICE_ADD);
      saveUser(sessUser);
    }

    res.json({ output: out });
  } catch (e) { res.status(500).json({ error: e.message }); }
}
app.post("/api/add/ssh", authRequired, handleAddSSH_json);

async function handleAddGeneric_json(req, res) {
  try {
    const kind = String(req.params.kind || "").toLowerCase();
    if (kind === "ssh") return handleAddSSH_json(req, res);
    const cfg = ADD_MAP[kind];
    if (!cfg) return res.status(400).json({ error: "Unsupported kind" });

    const remarks = (req.body.remarks || "").trim();
    const days = parseInt(req.body.days, 10) || 30;
    if (!remarks) return res.status(400).json({ error: "remarks is required" });
    if (days < 1 || days > 3650) return res.status(400).json({ error: "days out of range" });

    const sessUser = getUser(req.session.user.username);
    if (sessUser && (sessUser.role || "user") !== "admin") {
      if (Number(sessUser.balance || 0) < PRICE_ADD)
        return res.status(402).json({ error: "Saldo tidak cukup" });
    }

    const out = await sh(cfg.feed(remarks, days));

    if (sessUser && (sessUser.role || "user") !== "admin") {
      sessUser.balance = Math.max(0, Number(sessUser.balance || 0) - PRICE_ADD);
      saveUser(sessUser);
    }

    res.json({ output: out });
  } catch (e) { res.status(500).json({ error: e.message }); }
}
app.post("/api/add/:kind", authRequired, handleAddGeneric_json);

// Alias SS lama
function wrap(method, route, handler) { app[method](route, authRequired, handler); }
wrap("post", "/api/add/ss", (req, res) => { req.params = { kind: "ss" }; return handleAddGeneric_json(req, res); });
wrap("get",  "/api/add/ss", (req, res) => { req.params = { kind: "ss" }; return handleAddGeneric_json(req, res); });
wrap("post", "/api/add/shadowsocks", (req, res) => { req.params = { kind: "ss" }; return handleAddGeneric_json(req, res); });
wrap("get",  "/api/add/shadowsocks", (req, res) => { req.params = { kind: "ss" }; return handleAddGeneric_json(req, res); });

// ===== SSE JOB REGISTRY (buffered) =====
const jobs = new Map(); // id -> {em: EventEmitter, done:boolean, buf:Array<{type,data}>}

function newJob() {
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
  const em = new EventEmitter();
  jobs.set(id, { em, done: false, buf: [] });
  return { id, em };
}
function finishJob(id) {
  const j = jobs.get(id);
  if (j) {
    j.done = true;
    j.em.emit("done", {});
    j.buf.push({ type: "done" });
    setTimeout(() => jobs.delete(id), 5 * 60 * 1000);
  }
}
function pushBuf(id, evt) {
  const j = jobs.get(id);
  if (j) j.buf.push(evt);
}
function emitLine(id, line) {
  const j = jobs.get(id);
  if (!j) return;
  j.em.emit("line", line);
  pushBuf(id, { type: "line", data: line });
}
function emitBalance(id, amount) {
  const j = jobs.get(id);
  if (!j) return;
  j.em.emit("balance", amount);
  pushBuf(id, { type: "balance", amount });
}
// ===== Branding header/footer untuk semua job =====
const BRAND_LINE = "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”";
function emitHeader(id, title, sub) {
  emitLine(id, BRAND_LINE);
  emitLine(id, `CartenzVPN â€” ${title}`);
  if (sub) emitLine(id, sub);
  emitLine(id, BRAND_LINE);
}
function emitFooter(id, note="Selesai.") {
  emitLine(id, BRAND_LINE);
  emitLine(id, note);
  emitLine(id, BRAND_LINE);
}
// ===== SSE STREAM ENDPOINT (flush buffer on subscribe) =====
app.get("/api/stream/job/:id", authRequired, (req, res) => {
  const id = req.params.id;
  const job = jobs.get(id);
  if (!job) return res.status(404).end("no such job");

  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.flushHeaders?.();

  const send = (obj) => res.write(`data: ${JSON.stringify(obj)}\n\n`);
  const sendType = (type, extra = {}) => send({ type, ...extra });

  // 1) Flush semua event yang sempat terjadi sebelum subscribe
  for (const evt of job.buf) send(evt);

  // 2) Subscribe realtime
  const onLine = (s) => sendType("line", { data: s });
  const onBal  = (amt) => sendType("balance", { amount: amt });
  const onDone = () => sendType("done");

  job.em.on("line", onLine);
  job.em.on("balance", onBal);
  job.em.on("done", onDone);

  // 3) Heartbeat
  const hb = setInterval(() => res.write(": ping\n\n"), 15000);

  // 4) Jika job sudah selesai, pastikan 'done' terkirim (idempotent)
  if (job.done) sendType("done");

  req.on("close", () => {
    job.em.off("line", onLine);
    job.em.off("balance", onBal);
    job.em.off("done", onDone);
    clearInterval(hb);
  });
});




// ===== SSE: TRIAL (Admin bebas limit; user 1x/hari + lock aman) =====
// ===== SSE: TRIAL (Admin bebas limit & tidak kena lock) =====
app.post("/api/sse/trial/:kind", authRequired, async (req, res) => {
  const sessUname = req.session.user.username;
  const kind = String(req.params.kind || "").toLowerCase();

  const { id } = newJob();
  res.json({ jobId: id });
  emitHeader(id, `TRIAL ${kind.toUpperCase()}`);
  (async () => {
    const say = (s) => emitLine(id, s);
    try {
      const uFresh = getUser(sessUname) || { username: sessUname, role: "user", balance: 0, lastTrialDate: null };
      const isAdmin = (uFresh.role || "user") === "admin";
      const script = TRIAL_MAP[kind];
      if (!script) { say("Unsupported kind"); finishJob(id); return; }

      // âœ… Admin dilewati lock & limit harian
      if (isAdmin) {
        say("ðŸ‘‘ Mode admin: trial tidak dibatasi harian.");
        say("Membuat trial â€¦");
        await shStream(script, (line) => say(line));
        say("âœ… Trial berhasil (admin).");
        finishJob(id);
        return;
      }

      // ðŸ”’ Lock hanya untuk user biasa
      if (trialBusy.has(sessUname)) {
        say("â—ï¸ Trial sedang diproses, tunggu sampai selesai.");
        finishJob(id);
        return;
      }
      trialBusy.add(sessUname);

      try {
        const today = todayJakarta();
        if (uFresh.lastTrialDate === today) {
          say("âŒ Trial hari ini sudah digunakan. Coba lagi besok.");
          finishJob(id);
          return;
        }

        uFresh.lastTrialDate = today;
        saveUser(uFresh);

        say("Membuat trial â€¦");
        await shStream(script, (line) => say(line));
        say("âœ… Trial berhasil. Anda hanya bisa membuat 1 trial per hari.");
        finishJob(id);
      } finally {
        trialBusy.delete(sessUname);
      }
    } catch (e) {
      say(`ERROR: ${e.message}`);
      finishJob(id);
    }
  })();
});

// ===== List Accounts (parsing per inbound block) =====
function parseXrayAccounts() {
  const result = { vmess: [], vless: [], trojan: [], ss: [] };
  let txt = "";
  try {
    txt = fs.readFileSync("/etc/xray/config.json", "utf8");
  } catch {
    return result;
  }

  // Helper: ambil semua potongan inbound untuk suatu protocol
  function slicesFor(proto) {
    const out = [];
    const reStart = new RegExp(`"protocol"\\s*:\\s*"${proto}"`);
    let idx = 0;
    while (true) {
      const m = txt.slice(idx).match(reStart);
      if (!m) break;
      const start = idx + m.index;

      // Cari batas blok inbound terdekat (kira-kira): dari awal baris '{' terdekat sampai '},' berikutnya
      // Kita melakukan heuristik sederhana supaya robust walau ada komentar.
      let s = start;
      // mundur sampai '{'
      while (s > 0 && txt[s] !== "{") s--;
      if (txt[s] !== "{") break;

      // maju untuk balance kurung kurawal
      let depth = 0;
      let e = s;
      for (; e < txt.length; e++) {
        const ch = txt[e];
        if (ch === "{") depth++;
        else if (ch === "}") {
          depth--;
          if (depth === 0) { e++; break; }
        }
      }
      out.push(txt.slice(s, e));
      idx = e;
    }
    return out;
  }

  // 1) SHADOWSOCKS â€” marker `### user yyyy-mm-dd` berada di dalam blok SS (ws/grpc)
  const ssBlocks = slicesFor("shadowsocks");
  for (const blk of ssBlocks) {
    const lines = blk.split(/\r?\n/);
    for (const line of lines) {
      const m = line.match(/^###\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/);
      if (m) result.ss.push({ user: m[1], exp: m[2] });
    }
  }

  // 2) VLESS â€” banyak script pakai `#& user yyyy-mm-dd`
  (txt.match(/^#&\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/gm) || []).forEach(line => {
    const m = line.match(/^#&\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/);
    if (m) result.vless.push({ user: m[1], exp: m[2] });
  });

  // 3) TROJAN â€” marker umum `#! user yyyy-mm-dd`
  (txt.match(/^#!\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/gm) || []).forEach(line => {
    const m = line.match(/^#!\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/);
    if (m) result.trojan.push({ user: m[1], exp: m[2] });
  });

  // 4) VMESS â€” beberapa installer masih pakai `###` untuk VMess.
  //    Agar SS tidak â€œnumpangâ€, kita ambil `### ...` HANYA dari blok VMESS.
  const vmessBlocks = slicesFor("vmess");
  for (const blk of vmessBlocks) {
    const lines = blk.split(/\r?\n/);
    for (const line of lines) {
      const m = line.match(/^###\s+(\S+)\s+(\d{4}-\d{2}-\d{2})/);
      if (m) result.vmess.push({ user: m[1], exp: m[2] });
    }
  }

  // 5) Dedupe per jenis (kalau ada duplikat marker)
  const dedupe = (arr) => {
    const seen = new Set();
    return arr.filter(o => {
      const k = `${o.user}|${o.exp}`;
      if (seen.has(k)) return false;
      seen.add(k);
      return true;
    });
  };
  result.vmess  = dedupe(result.vmess);
  result.vless  = dedupe(result.vless);
  result.trojan = dedupe(result.trojan);
  result.ss     = dedupe(result.ss);

  return result;
}


async function listSSHAccounts() {
  const cmd = `
    awk -F: '($3>=1000)&&($7=="/bin/false"||$7=="/usr/sbin/nologin"){print $1}' /etc/passwd | while read u; do
      exp=$(chage -l "$u" | awk -F": " "/Account expires/{print \\$2}");
      echo "$u|$exp";
    done
  `;
  const out = await sh(cmd).catch(()=> "");
  const rows = (out||"").split("\n").filter(Boolean);
  return rows.map(r => {
    const [user, exp] = r.split("|");
    return { user, exp: (exp || "").trim() };
  });
}

app.get("/api/accounts", authRequired, async (req, res) => {
  try {
    const ssh = await listSSHAccounts().catch(() => []);
    const xr = parseXrayAccounts();
    res.json({ ssh, vmess: xr.vmess, vless: xr.vless, trojan: xr.trojan, ss: xr.ss });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// ===== Delete Accounts =====
app.delete("/api/accounts/:kind/:name", authRequired, async (req, res) => {
  try {
    const kind = String(req.params.kind || "").toLowerCase();
    const name = String(req.params.name || "").trim();
    if (!name) return res.status(400).json({ error: "name required" });

    if (kind === "ssh") {
      const out = await sh(`pkill -KILL -u '${name}' 2>/dev/null || true; userdel -f '${name}' && echo "deleted"`);
      return res.json({ ok: true, output: out });
    }

    const DEL = {
      vmess: "/usr/bin/del-ws",
      vless: "/usr/bin/del-vless",
      trojan: "/usr/bin/del-tr",
      ss: "/usr/bin/del-ssws",
      shadowsocks: "/usr/bin/del-ssws",
    }[kind];

    if (!DEL || !fileExists(DEL)) {
      return res
        .status(501)
        .json({ error: "delete-script not found", needed: DEL || "(unknown)" });
    }

    const out = await sh(`printf '%s\n' '${name}' | ${DEL}`);
    return res.json({ ok: true, output: out });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// ===== ADMIN =====
app.get("/api/admin/users", authRequired, adminRequired, (req, res) => {
  const users = readUsers().map(u => ({ username: u.username, role: u.role || "user", balance: u.balance || 0, lastTrialDate: u.lastTrialDate || null }));
  res.json({ users });
});
app.post("/api/admin/create-user", authRequired, adminRequired, (req, res) => {
  const { username="", password="", role="user", balance=0 } = req.body || {};
  if (!/^[a-zA-Z0-9_][a-zA-Z0-9_\-]{1,31}$/.test(username))
    return res.status(400).json({ error: "username invalid" });
  const users = readUsers();
  if (users.some(u => u.username === username)) return res.status(400).json({ error: "username exists" });
  const passhash = bcrypt.hashSync(password || "changeme123", 12);
  users.push({ username, passhash, role, balance: Number(balance)||0, lastTrialDate: null });
  writeUsers(users);
  res.json({ ok: true });
});
app.post("/api/admin/add-balance", authRequired, adminRequired, (req, res) => {
  const { username="", amount=0 } = req.body || {};
  const users = readUsers();
  const i = users.findIndex(u => u.username === username);
  if (i < 0) return res.status(404).json({ error: "user not found" });
  users[i].balance = Number(users[i].balance || 0) + Math.max(0, Number(amount)||0);
  writeUsers(users);
  res.json({ ok: true, balance: users[i].balance });
});

// ===== Health =====
app.get("/api/ping", (_req, res) => res.json({ ok: true }));

// ===== Start =====
ensureUsers();
app.listen(PORT, () => console.log(`[panel] listening on :${PORT}`));
